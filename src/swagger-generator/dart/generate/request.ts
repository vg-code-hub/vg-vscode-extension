import { find, first, join, mkdirpSync, existsSync, writeFileSync, writeFile, snakeCase, camelCase, isRegExp } from "@root/utils";
import type { SwaggerPropertyDefinition, SwaggerPath, Method, SwaggerHttpEndpoint, Responses } from "../../index.d";
import { BASE_TYPE, INDENT, SwaggerConfig, getDartParamType, getDartSchemaType, getDirPath } from "../../utils";

const METHOD_MAP = {
  get: 'get',
  post: 'create',
  put: 'update',
  delete: 'delete',
};

const rootName = 'requests';

class RequestGenerate {
  paths: SwaggerPath;
  filesMap: Record<string, string>;

  constructor(paths: SwaggerPath) {
    this.paths = paths;
    this.filesMap = {};
  }

  async generateAllRequest() {
    for (let key in this.paths)
      for (let method in this.paths[key])
        this.generateRequest(key, method as Method, this.paths[key][method as Method]) + "\n";

    let str = `library ${rootName};\n\n`;
    const requestsDir = join(SwaggerConfig.config.rootPath, rootName);

    // request内容写入
    for (let key in this.filesMap) {
      str += `export '.${key.replace(requestsDir, '')}/request.g.dart';\n`;
      if (!existsSync(join(key, 'request.g.dart')))
        writeFile(
          join(key, 'request.g.dart'),
          this.filesMap[key] + '}',
          'utf-8',
        );
      else
        writeFile(
          join(key, 'request.g.vg'),
          this.filesMap[key] + '}',
          'utf-8',
        );
    }

    // 内容写入 index.dart
    if (!existsSync(join(requestsDir, 'index.dart')))
      writeFileSync(
        join(requestsDir, 'index.dart'),
        str,
        'utf-8',
      );
    writeFileSync(
      join(requestsDir, 'index.text'),
      str,
      'utf-8',
    );

    // 内容写入 base_connect.dart  
    if (!existsSync(join(requestsDir, 'base_connect.dart')))
      writeFileSync(
        join(requestsDir, 'base_connect.dart'),
        `abstract class BaseConnect {
  onInit() {}
  dispose() {}
  get(path, {query}) {}
  post(path, body) {}
  put(path, body) {}
  delete(path, {query}) {}
}
/**
 * GetConnect
 * 
import 'package:get/get.dart';
class BaseConnect extends GetConnect {
  @override
  // ignore: overridden_fields
  Duration timeout = const Duration(seconds: 30);

  @override
  void onInit() {
    httpClient.baseUrl = 'xxx';

    httpClient.addRequestModifier<void>((request) {
      if (UserService.to.hasToken) {
        request.headers['Authorization'] = xxx.token;
      }
      return request;
    });

    httpClient.addResponseModifier((request, response) {
      if (response.body is Map && (response.body as Map)['success'] == false) {
        // do some thing
      }
      return response;
    });
  }
}
 */ 
`,
        'utf-8',
      );
  }

  generateRequest(key: string, method: Method, value: SwaggerHttpEndpoint) {
    const { rootPath, customPathFolder } = SwaggerConfig.config;
    let folder;
    if (customPathFolder)
      for (const customKey of customPathFolder.keys())
        if (isRegExp(customKey) && customKey.test(key)) {
          folder = customPathFolder.get(customKey);
          break;
        } else if (!isRegExp(customKey) && key.startsWith(customKey)) {
          folder = customPathFolder.get(customKey);
          break;
        }

    if (!folder) {
      folder = value["x-apifox-folder"];
      if (!folder && value.tags && value.tags.length > 0) folder = value.tags[0];
      if (!SwaggerConfig.testFolder(folder ?? '')) return;
      folder = SwaggerConfig.exchangeConfigMap(folder);
    }

    const translationObj = SwaggerConfig.translationObj;
    let { dirPath, deeps, className } = getDirPath(folder, rootName, { translationObj, rootPath }) as {
      className: string,
      dirPath: string,
      deeps: number
    };
    if (!existsSync(dirPath)) mkdirpSync(dirPath);
    const keyLast = key.split('/').map(e => snakeCase(e)).filter(e => !['create', 'delete', 'update', 'v1'].includes(e)).join('_');
    if (!keyLast) return;

    const methodName = camelCase(METHOD_MAP[method] + '_' + keyLast);

    // 写入 class 头
    if (!this.filesMap[dirPath])
      this.filesMap[dirPath] = `// @format
// This file is generated by the VG SwaggerGenerator.
// Do not edit.
import '${join(...Array(deeps).fill('..'), 'entitys', 'index.dart')}';
import '${join(...Array(deeps - 1).fill('..'), 'base_connect.dart')}';

class ${className} extends BaseConnect {
  static ${className} get instance => _getInstance();
  static ${className}? _instance;

  static ${className} _getInstance() {
    _instance ??= ${className}()..onInit();
    return _instance!;
  }

  @override
  dispose() {
    ${className}._instance = null;
  }\n`;

    const { params, desc } = this.getParams(value.parameters);
    const returnType = this.getReturnType(value.responses, method);
    const functionArgs = this.getFunctionArgs(key, method, value.parameters);
    const functionDesc = `
  /// ${value.summary}${value.description ? `\n${INDENT}/// ${value.description}` : ''}${value.operationId ? `\n${INDENT}/// Operation ID: ${value.operationId}` : ''}${desc}`;
    // 写入请求
    this.filesMap[dirPath] += `${functionDesc}
  ${returnType} ${methodName}(${params}) async {
    ${returnType !== 'Future<void>' ? 'final res = ' : ''}await ${method.toLowerCase()}(${functionArgs});${this.getReturnContent(value.responses, method)}
  }
`;
  }

  getParamObj(parameters: SwaggerHttpEndpoint['parameters']) {
    if (!parameters) return undefined;
    const pathParams =
      parameters.filter((p) => p['in'] === 'path');
    const queryParams =
      parameters.filter((p) => p['in'] === 'query');
    const formDataParams =
      parameters.filter((p) => p['in'] === 'body' && p['contentType'] === 'multipart/form-data');
    const bodyParams =
      parameters.filter((p) => p['in'] === 'body' && p['contentType'] !== 'multipart/form-data');

    return {
      pathParams,
      queryParams,
      formDataParams,
      bodyParams
    };
  }

  getReturnType(responses: Responses, method: Method) {
    let resClass: string | undefined;
    if (responses && responses['200'] && responses['200'].schema) {
      const schema = responses['200'].schema;
      if (schema.type === 'object' && schema.properties && Object.keys(schema.properties).includes('data')) {
        let rawData: SwaggerPropertyDefinition | undefined = schema.properties['data'];
        if (rawData['anyOf'])
          rawData = find(rawData['anyOf'], item => item.type !== 'null');
        resClass = rawData ? getDartSchemaType(rawData) : undefined;
      } else if (schema.$ref || schema.type) {
        resClass = getDartSchemaType(schema);
      }
    }

    return resClass !== undefined ? `Future<${resClass}>` : 'Future<void>';
  }

  getParams(parameters: SwaggerHttpEndpoint['parameters']) {
    const data = this.getParamObj(parameters);
    if (!data) return { params: '', desc: '' };
    const { pathParams, queryParams, formDataParams, bodyParams } = data;
    const swaggerVersion = SwaggerConfig.config.swaggerVersion;
    let str = '';
    let desc = `\n${INDENT}///\n${INDENT}/// parameters`;

    pathParams.forEach(p => {
      const name = camelCase(p.name);
      const type = getDartParamType(p, swaggerVersion);
      str += `${type} ${name}, `;

      const description = p?.description;
      desc += `\n${INDENT}/// [pathParam] ${type} ${name}:  ${description ?? ''}`;
    });
    if (queryParams.length > 0) str += '{\n';

    queryParams.forEach(p => {
      const name = camelCase(p.name);
      const type = getDartParamType(p, swaggerVersion);
      const require = p['required'];
      str += `${INDENT}${INDENT}${require ? 'required ' : ''}${type}${require ? '' : '?'} ${name},\n`;

      const description = p?.description;
      desc += `\n${INDENT}/// [queryParam] ${type}${require ? '' : '?'} ${name}: ${description ?? ''}`;
    });

    if (formDataParams.length > 0) {
      if (!str.includes('{')) str += '{\n';
      str += `${INDENT}${INDENT}required dynamic body,\n`;

      const description = formDataParams[0]?.description;
      desc += `\n${INDENT}/// [formDataParam] FormData body: ${description ?? ''}`;
    }
    if (bodyParams.length > 0) {
      if (!str.includes('{\n')) str += '{\n';
      const p = first(bodyParams)!;
      const type = getDartParamType(p, swaggerVersion);
      const require = p['required'];
      str += `${INDENT}${INDENT}${require ? 'required ' : ''}${type}${require ? '' : '?'} body,\n`;

      const description = formDataParams[0]?.description;
      desc += `\n${INDENT}/// [bodyParam] ${type}${require ? '' : '?'} body: ${description ?? ''}`;
    }

    if (str.includes('{')) str += `${INDENT}}`;

    return { params: str, desc };
  }

  getFunctionArgs(key: string, method: Method, parameters: SwaggerHttpEndpoint['parameters']) {
    const data = this.getParamObj(parameters);
    if (!data) return `'${key}'`;
    let str = '', reqPath = key, queryStr = '';
    const { pathParams, queryParams, formDataParams, bodyParams } = data;
    const swaggerVersion = SwaggerConfig.config.swaggerVersion;

    pathParams.forEach(p => {
      const name = camelCase(p.name);
      if (reqPath.includes(`{${p.name}}`))
        reqPath = reqPath.replace(`{${p.name}}`, `\${${name}}`);
      else
        reqPath += reqPath.endsWith('/') ? `\${${name}}` : `/\${${name}}`;
    });
    str += `'${reqPath}'`;
    if (bodyParams.length > 0 && ['put', 'post', 'delete'].includes(method)) {
      const p = first(bodyParams)!;
      const type = getDartParamType(p, swaggerVersion);
      const require = p['required'];

      var suffix = '';
      if (type && !BASE_TYPE.includes(type)) suffix = `.toJson()`;
      else if (type && ['int', 'double'].includes(type)) suffix = `.toString()`;

      str += `, body${require || !suffix ? '' : '?'}${suffix}`;
    }
    if (formDataParams.length > 0 && !str.includes(', body') && ['put', 'post', 'delete'].includes(method)) str += ', body';

    if (queryParams.length > 0) {
      queryStr += '{';
      queryParams.forEach(p => {
        const type = getDartParamType(p, swaggerVersion);
        const name = camelCase(p.name);
        const require = p['required'];
        var suffix = '';
        if (type && !BASE_TYPE.includes(type)) suffix = `.toJson()`;
        else if (type && ['int', 'double'].includes(type)) suffix = `.toString()`;
        queryStr += `\'${p.name}\': ${name}${require || !suffix ? '' : '?'}${suffix}, `;
      });
      queryStr += '}';
    }
    if (queryStr.length !== 0) str += `, query: ${queryStr}`;
    return str;
  }

  getReturnContent(responses: SwaggerHttpEndpoint['responses'], method: Method) {
    const returnType = this.getReturnType(responses, method);
    if (returnType === 'Future<void>') return '';
    let type = returnType.substring(7, returnType.length - 1);
    if (BASE_TYPE.includes(type) || type === 'List<Map<String, dynamic>>' || type === 'Map<String, dynamic>') {
      return `\n${INDENT}${INDENT}return res.body['data'];`;
    } else if (type.startsWith('List')) {
      const subType = type.substring(5, type.length - 1);
      return `\n${INDENT}${INDENT}return res.body['data'] == null ? [] : ${type}.from(res.body['data'].map((e) => ${subType}.fromJson(e)));`;
    } else {
      return `\n${INDENT}${INDENT}return ${type}.fromJson(res.body['data']);`;
    }
  }
}

export default RequestGenerate;