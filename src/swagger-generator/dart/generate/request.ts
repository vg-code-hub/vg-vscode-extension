import { find, first, join, mkdirpSync, existsSync, writeFileSync, writeFile, snakeCase, camelCase, isRegExp, upperFirst } from "@root/utils";
import type { SwaggerPropertyDefinition, SwaggerPath, Method, SwaggerHttpEndpoint, Responses } from "../../index.d";
import { BASE_TYPE, INDENT, SwaggerConfig, getDartParamType, getDartSchemaType, getDirPath } from "../../utils";
import { getModelClassContent } from "./model_tool";

const METHOD_MAP = {
  get: 'get',
  post: 'create',
  put: 'update',
  delete: 'delete',
};

const rootName = 'requests';

class RequestGenerate {
  paths: SwaggerPath;
  filesMap: Record<string, [api: string, model: string]>;

  constructor(paths: SwaggerPath) {
    this.paths = paths;
    this.filesMap = {};
  }

  async generateAllRequest() {
    for (let key in this.paths)
      for (let method in this.paths[key])
        this.generateRequest(key, method as Method, this.paths[key][method as Method]) + "\n";

    let str = `library ${rootName};\n\n`;
    const requestsDir = join(SwaggerConfig.config.rootPath);
    const overwrite = SwaggerConfig.config.overwrite ?? false;

    // request内容写入
    for (let key in this.filesMap) {
      str += `export '.${key.replace(requestsDir, '')}/model.g.dart';\n`;
      str += `export '.${key.replace(requestsDir, '')}/request.g.dart';\n`;
      const [apiContent, modelContent] = this.filesMap[key];
      if (!overwrite) {
        writeFile(
          join(key, 'request.g.vg'),
          apiContent + '}',
          'utf-8',
        );
        writeFile(
          join(key, 'model.g.vg'),
          modelContent,
          'utf-8',
        );
      }
      if (!existsSync(join(key, 'request.g.dart')) || overwrite) {
        writeFile(
          join(key, 'request.g.dart'),
          apiContent + '}',
          'utf-8',
        );
        writeFile(
          join(key, 'model.g.dart'),
          modelContent,
          'utf-8',
        );
      }
    }

    // 内容写入 index.dart
    if (!existsSync(join(requestsDir, 'index.dart')))
      writeFileSync(
        join(requestsDir, 'index.dart'),
        str,
        'utf-8',
      );
    writeFileSync(
      join(requestsDir, 'index.text'),
      str,
      'utf-8',
    );

    // 内容写入 base_connect.dart  
    if (!existsSync(join(requestsDir, 'base_connect.dart')))
      writeFileSync(
        join(requestsDir, 'base_connect.dart'),
        `abstract class GetConnect {
  onInit() {}
  dispose() {}
  get(path, {query}) {}
  post(path, body) {}
  put(path, body) {}
  delete(path, {query}) {}
}

class BaseProvider extends GetConnect {}

var httpInstance = BaseProvider()..onInit();
class PageResp<T> {
  List<T> data;
  int page;
  int size;
  int total;

  PageResp(
    this.data, {
    required this.page,
    required this.size,
    required this.total,
  });
}
`,
        'utf-8',
      );
    SwaggerConfig.writeExceptionToFile(requestsDir);
  }

  generateRequest(key: string, method: Method, value: SwaggerHttpEndpoint) {
    const { rootPath, customPathFolder } = SwaggerConfig.config;
    let folder;
    if (customPathFolder)
      for (const customKey of customPathFolder.keys())
        if (isRegExp(customKey) && customKey.test(key)) {
          folder = customPathFolder.get(customKey);
          break;
        } else if (!isRegExp(customKey) && key.startsWith(customKey)) {
          folder = customPathFolder.get(customKey);
          break;
        }

    if (!folder) {
      folder = value["x-apifox-folder"];
      if (!folder && value.tags && value.tags.length > 0) folder = value.tags[0];
      if (!SwaggerConfig.testFolder(folder ?? '')) return;
      folder = SwaggerConfig.exchangeConfigMap(folder);
    }

    const translationObj = SwaggerConfig.translationObj;
    let { dirPath, deeps, className } = getDirPath(folder, rootName, { translationObj, rootPath }) as {
      className: string,
      dirPath: string,
      deeps: number
    };
    if (!existsSync(dirPath)) mkdirpSync(dirPath);
    const _temp = key.split('/').map(e => camelCase(e)).filter(e => !['create', 'delete', 'update', 'v1', ''].includes(e));
    const keyLast = _temp.join('_');
    if (!keyLast) return;

    const methodName = camelCase(METHOD_MAP[method] + '_' + keyLast);
    const overwrite = SwaggerConfig.config.overwrite ?? false;

    // 写入 class 头
    if (!this.filesMap[dirPath]) {
      const modelHeader = `// This file is generated by the VG SwaggerGenerator.
// ${overwrite ? 'Do not edit, next time generation will overwrite it!' : 'Next time generation will not overwrite it, but instead generate a suffix of (.vg) file with the same name.'}`;
      const apiHeader = `${modelHeader}
import '${join(...Array(deeps - 1).fill('..'), 'base_connect.dart')}';
import 'model.g.dart';

class ${className} {\n`;

      this.filesMap[dirPath] = [apiHeader, modelHeader];
    }

    // const _temp = key.split('/').map(e => camelCase(e)).filter(e => !['create', 'delete', 'update', 'v1'].includes(e));
    let _name = '';
    if (_temp.length === 1) {
      _name = upperFirst(_temp[0]);
    } else {
      const last = _temp[_temp.length - 1];
      const last1 = _temp[_temp.length - 2];
      if (last.includes(last1))
        _name = upperFirst(last);
      else
        _name = upperFirst(last1) + upperFirst(last);
    }
    this.filesMap[dirPath][1] = getModelClassContent(_name, value, this.filesMap[dirPath][1]);

    const { params, desc } = this.getParams(value.parameters);
    let returnType = this.getReturnType(value.responses, method);
    if (returnType.includes('Map<String, dynamic>'))
      returnType = returnType.replace('Map<String, dynamic>', _name + 'Resp');
    if (key === '/project/finish') {
      console.log(returnType);
      console.log(returnType);

    }
    const functionArgs = this.getFunctionArgs(key, method, value.parameters);
    const functionDesc = `
  /// ${value.summary}${value.description ? `\n${INDENT}/// ${value.description}` : ''}${value.operationId ? `\n${INDENT}/// Operation ID: ${value.operationId}` : ''}${desc}`;
    // 写入请求
    this.filesMap[dirPath][0] += `${functionDesc}
  static Future<${returnType}> ${methodName}(${params}) async {
    ${returnType !== 'void' ? 'final res = ' : ''}await httpInstance.${method.toLowerCase()}(${functionArgs});${this.getReturnContent(value.responses, method)}
  }
`;
  }

  getParamObj(parameters: SwaggerHttpEndpoint['parameters']) {
    if (!parameters) return undefined;
    const pathParams =
      parameters.filter((p) => p['in'] === 'path');
    const queryParams =
      parameters.filter((p) => p['in'] === 'query');
    const formDataParams =
      parameters.filter((p) => p['in'] === 'body' && p['contentType'] === 'multipart/form-data');
    const bodyParams =
      parameters.filter((p) => p['in'] === 'body' && p['contentType'] !== 'multipart/form-data');

    return {
      pathParams,
      queryParams,
      formDataParams,
      bodyParams
    };
  }

  getReturnType(responses: Responses, method: Method) {
    let resClass: string | undefined, isPageResp = false;
    if (responses && responses['200'] && responses['200'].schema) {
      const schema = responses['200'].schema;

      if (schema.type === 'object' && schema.properties && Object.keys(schema.properties).includes('data')) {
        // 普通对象返回值
        let rawData: SwaggerPropertyDefinition | undefined = schema.properties['data'];
        if (rawData['anyOf'])
          rawData = find(rawData['anyOf'], item => item.type !== 'null');
        resClass = rawData ? getDartSchemaType(rawData) : undefined;
      } else if (schema.allOf && schema.allOf.length > 1 && schema.allOf[0].$ref?.includes('utils.Result')) {
        // 包装对象返回值
        let rawData: SwaggerPropertyDefinition | undefined = schema.allOf[1].properties['data'];
        if (rawData.allOf && rawData.allOf.length > 1 && rawData.allOf[0].$ref?.includes('utils.PageData')) {
          // 包装分页对象返回值
          rawData = rawData.allOf[1].properties['data'];
          if (rawData.type === 'array')
            rawData = rawData.items;

          isPageResp = true;
        }

        if (rawData['anyOf'])
          rawData = find(rawData['anyOf'], item => item.type !== 'null');

        if (rawData && !Array.isArray(rawData))
          resClass = getDartSchemaType(rawData);

        if (isPageResp)
          resClass = `PageResp<${resClass}>`;
      }
    }
    return resClass !== undefined ? resClass : 'void';
  }

  getParams(parameters: SwaggerHttpEndpoint['parameters']) {
    const data = this.getParamObj(parameters);
    if (!data) return { params: '', desc: '' };
    const { pathParams, queryParams, formDataParams, bodyParams } = data;
    const swaggerVersion = SwaggerConfig.config.swaggerVersion;
    let str = '';
    let desc = `\n${INDENT}///\n${INDENT}/// parameters`;

    pathParams.forEach(p => {
      const name = camelCase(p.name);
      const type = getDartParamType(p, swaggerVersion);
      str += `${type} ${name}, `;

      const description = p?.description;
      desc += `\n${INDENT}/// [pathParam] ${type} ${name}:  ${description ?? ''}`;
    });
    if (queryParams.length > 0) str += '{\n';

    queryParams.forEach(p => {
      const name = camelCase(p.name);
      const type = getDartParamType(p, swaggerVersion);
      const require = p['required'];
      str += `${INDENT}${INDENT}${require ? 'required ' : ''}${type}${require ? '' : '?'} ${name},\n`;

      const description = p?.description;
      desc += `\n${INDENT}/// [queryParam] ${type}${require ? '' : '?'} ${name}: ${description ?? ''}`;
    });

    if (formDataParams.length > 0) {
      if (!str.includes('{')) str += '{\n';
      str += `${INDENT}${INDENT}required dynamic body,\n`;

      const description = formDataParams[0]?.description;
      desc += `\n${INDENT}/// [formDataParam] FormData body: ${description ?? ''}`;
    }
    if (bodyParams.length > 0) {
      if (!str.includes('{\n')) str += '{\n';
      const p = first(bodyParams)!;
      const type = getDartParamType(p, swaggerVersion);
      const require = p['required'];
      str += `${INDENT}${INDENT}${require ? 'required ' : ''}${type}${require ? '' : '?'} body,\n`;

      const description = formDataParams[0]?.description;
      desc += `\n${INDENT}/// [bodyParam] ${type}${require ? '' : '?'} body: ${description ?? ''}`;
    }

    if (str.includes('{')) str += `${INDENT}}`;

    return { params: str, desc };
  }

  getFunctionArgs(key: string, method: Method, parameters: SwaggerHttpEndpoint['parameters']) {
    const data = this.getParamObj(parameters);
    if (!data) return `'${key}'`;
    let str = '', reqPath = key, queryStr = '';
    const { pathParams, queryParams, formDataParams, bodyParams } = data;
    const swaggerVersion = SwaggerConfig.config.swaggerVersion;

    pathParams.forEach(p => {
      const name = camelCase(p.name);
      if (reqPath.includes(`{${p.name}}`))
        reqPath = reqPath.replace(`{${p.name}}`, `\${${name}}`);
      else
        reqPath += reqPath.endsWith('/') ? `\${${name}}` : `/\${${name}}`;
    });
    str += `'${reqPath}'`;
    if (bodyParams.length > 0 && ['put', 'post'].includes(method)) {
      const p = first(bodyParams)!;
      const type = getDartParamType(p, swaggerVersion);
      const require = p['required'];

      var suffix = '';
      if (type && !BASE_TYPE.includes(type)) suffix = `.toJson()`;
      else if (type && ['int', 'double'].includes(type)) suffix = `.toString()`;

      str += `, body${require || !suffix ? '' : '?'}${suffix}`;
    }
    if (formDataParams.length > 0 && !str.includes(', body') && ['put', 'post'].includes(method)) str += ', body';

    if (queryParams.length > 0) {
      queryStr += '{';
      queryParams.forEach(p => {
        const type = getDartParamType(p, swaggerVersion);
        const name = camelCase(p.name);
        const require = p['required'];
        var suffix = '';
        if (type && !BASE_TYPE.includes(type)) suffix = `.toJson()`;
        else if (type && ['int', 'double'].includes(type)) suffix = `.toString()`;
        queryStr += `\'${p.name}\': ${name}${require || !suffix ? '' : '?'}${suffix}, `;
      });
      queryStr += '}';
    }
    if (queryStr.length !== 0) str += `, query: ${queryStr}`;
    return str;
  }

  getReturnContent(responses: SwaggerHttpEndpoint['responses'], method: Method) {
    const returnType = this.getReturnType(responses, method);
    if (returnType === 'void') return '';
    let type = returnType;
    if (BASE_TYPE.includes(type) || type === 'List<Map<String, dynamic>>' || type === 'Map<String, dynamic>') {
      return `\n${INDENT}${INDENT}return res.body['data'];`;
    } else if (type.startsWith('List')) {
      const subType = type.substring(5, type.length - 1);
      return `\n${INDENT}${INDENT}return res.body['data'] == null ? [] : ${type}.from(res.body['data'].map((e) => ${subType}.fromJson(e)));`;
    } else if (type.startsWith('PageResp')) {
      const subType = type.substring(9, type.length - 1);
      return `\n${INDENT}${INDENT}var pageData = res.body['data'];
    List<${subType}> data = pageData['data'] == null
        ? []
        : List<${subType}>.from(
            pageData['data'].map((e) => ${subType}.fromJson(e)));
    return PageResp(
      data,
      page: pageData['page'],
      size: pageData['size'],
      total: pageData['total'],
    );`;
    } else {
      return `\n${INDENT}${INDENT}return ${type}.fromJson(res.body['data']);`;
    }
  }
}

export default RequestGenerate;