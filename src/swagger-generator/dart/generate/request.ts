import { find, first, join, mkdirpSync, existsSync, writeFileSync, writeFile, camelCase, isRegExp, upperFirst } from '@root/utils';
import type { SwaggerPath, Method, SwaggerHttpEndpoint, JSONSchema } from '../../index.d';
import {
  DART_TYPE,
  METHOD_MAP,
  INDENT,
  SwaggerConfig,
  filterPathName,
  getClassName,
  getDartType,
  getDirPath,
  getParamObj,
  isPaginationResponse,
  isStandardResponse,
  LIST_KEY,
} from '../../utils';
import { arrayClass, getModelClassContent } from './model_tool';

const rootName = 'requests';

const getDartReturnType = (resClass?: string, isPagination = false) => {
  if (!resClass) return undefined;
  if (resClass.startsWith('List<')) {
    const subType = arrayClass(resClass);
    return isPagination ? `PageResp<${subType}>` : resClass;
  }
  return resClass;
};

class RequestGenerate {
  paths: SwaggerPath;
  filesMap: Record<string, [api: string, model: string]>;

  constructor(paths: SwaggerPath) {
    this.paths = paths;
    this.filesMap = {};
  }

  async generateAllRequest() {
    for (let key in this.paths) for (let method in this.paths[key]) this.generateRequest(key, method as Method, this.paths[key][method as Method]) + '\n';

    let str = `library ${rootName};\n\n`;
    const requestsDir = join(SwaggerConfig.config.rootPath);
    const overwrite = SwaggerConfig.config.overwrite ?? false;

    // request内容写入
    for (let key in this.filesMap) {
      str += `export '.${key.replace(requestsDir, '')}/model.g.dart';\n`;
      str += `export '.${key.replace(requestsDir, '')}/request.g.dart';\n`;
      const [apiContent, modelContent] = this.filesMap[key];
      if (!overwrite) {
        writeFile(join(key, 'request.g.vg'), apiContent + '}', 'utf-8');
        writeFile(join(key, 'model.g.vg'), modelContent, 'utf-8');
      }
      if (!existsSync(join(key, 'request.g.dart')) || overwrite) {
        writeFile(join(key, 'request.g.dart'), apiContent + '}', 'utf-8');
        writeFile(join(key, 'model.g.dart'), modelContent, 'utf-8');
      }
    }

    // 内容写入 index.dart
    if (!existsSync(join(requestsDir, 'index.dart'))) writeFileSync(join(requestsDir, 'index.dart'), str, 'utf-8');
    writeFileSync(join(requestsDir, 'index.text'), str, 'utf-8');

    // 内容写入 base_connect.dart
    if (!existsSync(join(requestsDir, 'base_connect.dart')))
      writeFileSync(
        join(requestsDir, 'base_connect.dart'),
        `abstract class GetConnect {
  onInit() {}
  dispose() {}
  get(path, {query}) {}
  post(path, body) {}
  put(path, body) {}
  delete(path, {query}) {}
}
abstract class FormData {}

class BaseProvider extends GetConnect {}

var httpInstance = BaseProvider()..onInit();
class PageResp<T> {
  List<T> data;
  int page;
  int size;
  int total;

  PageResp(
    this.data, {
    required this.page,
    required this.size,
    required this.total,
  });
}
`,
        'utf-8'
      );
    SwaggerConfig.writeExceptionToFile(requestsDir);
  }

  generateRequest(key: string, method: Method, value: SwaggerHttpEndpoint) {
    const { rootPath, customPathFolder } = SwaggerConfig.config;
    let folder;
    if (customPathFolder)
      for (const customKey of customPathFolder.keys())
        if (isRegExp(customKey) && customKey.test(key)) {
          folder = customPathFolder.get(customKey);
          break;
        } else if (!isRegExp(customKey) && key.startsWith(customKey)) {
          folder = customPathFolder.get(customKey);
          break;
        }

    if (!folder) {
      folder = value['x-apifox-folder'];
      if (!folder && value.tags && value.tags.length > 0) folder = value.tags[0];
      if (!SwaggerConfig.testFolder(folder ?? '')) return;
      folder = SwaggerConfig.exchangeConfigMap(folder);
    }

    const translationObj = SwaggerConfig.translationObj;
    let { dirPath, deeps, className } = getDirPath(folder, { translationObj, rootPath }) as {
      className: string;
      dirPath: string;
      deeps: number;
    };
    if (!existsSync(dirPath)) mkdirpSync(dirPath);
    const _temp = key
      .split('/')
      .map((e) => camelCase(e))
      .filter((e) => !['create', 'delete', 'update', 'v1', ''].includes(e));
    const keyLast = _temp.join('_');
    if (!keyLast) return;

    const methodName = camelCase(METHOD_MAP[method] + '_' + keyLast);
    const overwrite = SwaggerConfig.config.overwrite ?? false;

    // 写入 class 头
    if (!this.filesMap[dirPath]) {
      const modelHeader = `// This file is generated by the VG SwaggerGenerator.
// ${
        overwrite
          ? 'Do not edit, next time generation will overwrite it!'
          : 'Next time generation will not overwrite it, but instead generate a suffix of (.vg) file with the same name.'
      }`;
      const apiHeader = `${modelHeader}
import '${join(...Array(deeps - 1).fill('..'), 'base_connect.dart')}';
import 'model.g.dart';

class ${className} {\n`;

      this.filesMap[dirPath] = [apiHeader, modelHeader];
    }

    var _name = filterPathName(_temp);

    if (key === '/device/devices') {
      console.log(key);
      console.log(key);
    }
    this.filesMap[dirPath][1] = getModelClassContent(_name, value, this.filesMap[dirPath][1]);
    const reqClassName = getClassName(_name);

    const { params, desc } = this.getParams(value.parameters, reqClassName);
    let returnType = this.getReturnType(value.successResponse, getClassName(_name, false));

    const functionArgs = this.getFunctionArgs(key, method, value.parameters);
    const functionDesc = `
  /// ${value.summary}${value.description ? `\n${INDENT}/// ${value.description}` : ''}${
      value.operationId ? `\n${INDENT}/// Operation ID: ${value.operationId}` : ''
    }${desc}`;
    // 写入请求
    this.filesMap[dirPath][0] += `${functionDesc}
  static Future<${returnType}> ${methodName}(${params}) async {
    ${returnType !== 'void' ? 'final res = ' : ''}await httpInstance.${method.toLowerCase()}(${functionArgs});${this.getReturnContent(
      value.successResponse,
      getClassName(_name, false)
    )}
  }
`;
  }

  getReturnType(responses: JSONSchema | undefined, resClassName: string) {
    if (!responses) return 'any';
    let resClass: string | undefined,
      isPagination = false;
    let standardRes: JSONSchema | undefined = isStandardResponse(responses);
    if (standardRes) {
      const pageData = isPaginationResponse(standardRes);
      if (pageData) {
        standardRes = pageData;
        isPagination = true;
      }
      if (standardRes['anyOf']) standardRes = find(standardRes['anyOf'], (item) => item.type !== 'null');
      resClass = standardRes ? getDartType({ property: standardRes, key: resClassName }) : undefined;
    } else {
      resClass = 'dynamic';
    }
    resClass = getDartReturnType(resClass, isPagination);
    return resClass !== undefined ? `${resClass}` : 'void';
  }

  getParams(parameters: SwaggerHttpEndpoint['parameters'], reqClassName: string) {
    const data = getParamObj(parameters);
    if (!data) return { params: '', desc: '' };
    const { pathParams, queryParams, formDataParams, bodyParams } = data;

    let str = '';
    let desc = `\n${INDENT}///\n${INDENT}/// parameters`;

    pathParams.forEach((p) => {
      const name = camelCase(p.name);
      const type = getDartType({ param: p });
      str += `${type} ${name}, `;

      const description = p?.description;
      desc += `\n${INDENT}/// [pathParam] ${type} ${name}:  ${description ?? ''}`;
    });
    if (queryParams.length > 0) str += '{\n';

    queryParams.forEach((p) => {
      const name = camelCase(p.name);
      const type = getDartType({ param: p });
      const require = p['required'];
      str += `${INDENT}${INDENT}${require ? 'required ' : ''}${type}${require ? '' : '?'} ${name},\n`;

      const description = p?.description;
      desc += `\n${INDENT}/// [queryParam] ${type}${require ? '' : '?'} ${name}: ${description ?? ''}`;
    });

    if (formDataParams.length > 0) {
      if (!str.includes('{')) str += '{\n';
      str += `${INDENT}${INDENT}required FormData body,\n`;

      const description = formDataParams[0]?.description;
      desc += `\n${INDENT}/// [formDataParam] FormData body: ${description ?? ''}`;
    }
    if (bodyParams.length > 0) {
      if (!str.includes('{\n')) str += '{\n';
      const p = first(bodyParams)!;
      const type = getDartType({ param: p, key: reqClassName });
      const require = p['required'];
      str += `${INDENT}${INDENT}${require ? 'required ' : ''}${type}${require ? '' : '?'} body,\n`;

      const description = formDataParams[0]?.description;
      desc += `\n${INDENT}/// [bodyParam] ${type}${require ? '' : '?'} body: ${description ?? ''}`;
    }

    if (str.includes('{')) str += `${INDENT}}`;

    return { params: str, desc };
  }

  getFunctionArgs(key: string, method: Method, parameters: SwaggerHttpEndpoint['parameters']) {
    const data = getParamObj(parameters);
    const { urlPrefix } = SwaggerConfig.config;
    const path = (urlPrefix ?? '') + key;
    if (!data) return `'${path}'`;
    let str = '',
      reqPath = path,
      queryStr = '';
    const { pathParams, queryParams, formDataParams, bodyParams } = data;

    pathParams.forEach((p) => {
      const name = camelCase(p.name);
      if (reqPath.includes(`{${p.name}}`)) reqPath = reqPath.replace(`{${p.name}}`, `\$${name}`);
      else reqPath += reqPath.endsWith('/') ? `\$${name}` : `/\$${name}`;
    });
    str += `'${reqPath}'`;
    if (bodyParams.length > 0 && ['put', 'post'].includes(method)) {
      const p = first(bodyParams)!;
      const type = getDartType({ param: p });
      const require = p['required'];

      var suffix = '';
      if (type && !DART_TYPE.includes(type)) suffix = `.toJson()`;
      else if (type && ['int', 'double'].includes(type)) suffix = `.toString()`;

      str += `, body${require || !suffix ? '' : '?'}${suffix}`;
    }
    if (formDataParams.length > 0 && !str.includes(', body') && ['put', 'post'].includes(method)) str += ', body';

    if (queryParams.length > 0) {
      queryStr += '{';
      queryParams.forEach((p) => {
        const type = getDartType({ param: p });
        const name = camelCase(p.name);
        const require = p['required'];
        var suffix = '';
        if (type && !DART_TYPE.includes(type)) suffix = `.toJson()`;
        else if (type && ['int', 'double'].includes(type)) suffix = `.toString()`;
        queryStr += `\'${p.name}\': ${name}${require || !suffix ? '' : '?'}${suffix}, `;
      });
      queryStr += '}';
    }
    if (queryStr.length !== 0) str += `, query: ${queryStr}`;
    if (!str.includes(',') && ['put', 'post'].includes(method)) str += ', {}';
    return str;
  }

  getReturnContent(responses: JSONSchema | undefined, resClassName: string) {
    const returnType = this.getReturnType(responses, resClassName);
    if (returnType === 'void') return '';
    if (!isStandardResponse(responses)) return `\n${INDENT}${INDENT}return res;`;

    let type = returnType;
    if (DART_TYPE.includes(type) || type === 'List<Map<String, dynamic>>') {
      return `\n${INDENT}${INDENT}return res.body['data'];`;
    } else if (type.startsWith('List')) {
      const subType = type.substring(5, type.length - 1);
      return `\n${INDENT}${INDENT}return res.body['data'] == null ? [] : ${type}.from(res.body['data'].map((e) => ${subType}.fromJson(e)));`;
    } else if (type.startsWith('PageResp')) {
      const subType = type.substring(9, type.length - 1);
      return `\n${INDENT}${INDENT}var pageData = res.body['data'];
    List<${subType}> data = pageData['${LIST_KEY}'] == null
        ? []
        : List<${subType}>.from(
            pageData['${LIST_KEY}'].map((e) => ${subType}.fromJson(e)));
    return PageResp(
      data,
      page: pageData['page'],
      size: pageData['size'],
      total: pageData['total'],
    );`;
    } else {
      return `\n${INDENT}${INDENT}return ${type}.fromJson(res.body['data']);`;
    }
  }
}

export default RequestGenerate;
